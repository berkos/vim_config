module AuthorizationHelper

  def pending_payments(user)
    customer = Stripe::Customer.retrieve(user.customer_stripe_id)
    customer.delinquent
  end

#------------------------ method specific with articles access ----------------------------- 
  def can_read_specific(article, user)

    return true if article.tags.where(name: "free").present?

    return false if user.nil?

    return category_check_authorization(article, "nfl", user) ||
           category_check_authorization(article, "cfb", user) ||
           category_check_authorization(article, "mlb", user) ||
           category_check_authorization(article, "nba", user) ||
           category_check_authorization(article, "soc", user) ||
           category_check_authorization(article, "mma", user) ||
           category_check_authorization(article, "cbb", user) ||
           category_check_authorization(article, "mlb basic", user) ||
           category_check_authorization(article, "nhl", user)
  end

#------------------------ method specific add-ons , for now we have only nfl and mlb addons -----------------------------
  def valid_add_on_subscription?(user, tag)  
    return false if user.nil?

    return true if user.admin?

    if tag == 'nfl'
      user.admin? || user.subscriptions.any? { |subscription| subscription.name == "NFL Add-On" &&
                                             subscription.valid_until > Time.now }

    elsif tag == 'mlb'
      user.subscriptions.any? { |subscription| (['Add on', 'MLB Add-On'].include? subscription.name) &&
                                             subscription.valid_until > Time.now }
    else
      raise 'non valid tag'
    end
  end
#------------------------ method specific with the premium authorization (just like articles but an article var in not required, you can use tag direct) -----------------------------
  def premium_authorization(user, tag)
    return false if user.nil?
    return true if user.admin?
    fdsfsdf
    return true if check_stripe_authorization(tag, user)
    return true if check_stripe_single_payment_auhorization(tag, user)
    return true if check_backend_authorization(tag, user)
    return true if check_paypal_reccuring(tag,user)
  end

  #--------------------                                                                                ----------------------------------------------------------------------------------------------
  #--------------------   All the below methods are to support the above 3 main authorization methods  ----------------------------------------------------------------------------------------------
  #--------------------                                                                                ----------------------------------------------------------------------------------------------


  def category_check_authorization(article, tag, user)
    if article.tags.where(name: tag).present?
      return true if check_stripe_authorization(tag, user)
      return true if check_stripe_single_payment_auhorization(tag, user)
      return true if check_backend_authorization(tag, user)
      return true if check_paypal_reccuring(tag,user)
    end
  end

  def check_paypal_reccuring(tag,user)
    user.subscriptions.any? { |subscription| subscription.paypal_recurring_profile_token.present? &&
                             paypal_authorized?(subscription, user) }
  end

  def check_stripe_authorization(tag, user)
    # commenting the monthly different plans for future use!
    # possible_stripe_plans = ["nfl-monthly","nfl-seasonal","all-inclusive-annual"] if tag == "nfl"
    # possible_stripe_plans = ["cfb-monthly","cfb-seasonal","all-inclusive-annual"] if tag == "cfb"
    # possible_stripe_plans = ["mlb-monthly","mlb-seasonal","all-inclusive-annual"] if tag == "mlb"
    # possible_stripe_plans = ["nba-monthly","nba-seasonal","all-inclusive-annual"] if tag == "nba"

    possible_stripe_plans = ["all-inclusive-monthly", "all-inclusive-annual"] 

    if user.subscriptions.find_by_stripe(possible_stripe_plans).present?
     return !pending_payments(user)
    end
  end

  def check_stripe_single_payment_auhorization(tag, user)
    #check_backend_authorization(tag,user)
    name_plan = "Football (NFL) seasonal" if tag == "nfl"
    name_plan = "College Football (NCAAF) seasonal" if tag == "cfb"
    name_plan = "Baseball (MLB) seasonal" if tag == "mlb"
    name_plan = "Basketball (NBA) seasonal" if tag == "nba"
    name_plan = "Baseball (MLB) Seasonal Basic" if tag == "mlb basic"

    user.subscriptions.any? { |subscription| subscription.name == name_plan &&
                                             subscription.valid_until > Time.now }
  end

  def check_backend_authorization(tag,user)
    user.subscriptions.any? { |subscription| (subscription.stripe == nil) && 
                                             subscription.tags.where(name: tag).present? &&
                                             subscription.valid_until > Time.now }
  end

  private
  def paypal_authorized?(subscription, user)
    begin
      ppr = PayPal::Recurring.new(profile_id: subscription.paypal_recurring_profile_token)
      unless ppr.profile.active?
        SubscriptionCancellation.create(user_email: user.email, name: subscription.name, date_of_cancellation: Time.now(), sub_id: subscription.paypal_recurring_profile_token, comments: 'This Subscription was found non-active from paypal side.')
        subscription.destroy # we delete the subscription if it was canceled from paypal
        return false
      end
      ppr.profile.outstanding_balance == '0.00'
    rescue Exception => e
      ErrorMailer.paypal_errors(e, user).deliver
      return true
    end
  end
end
